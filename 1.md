# 悄悄地，打枪地不要：真正有效的网络时序攻击

这段文字表达了作者对时序攻击（Timing attacks）的复杂感受和个人研究经历。作者指出，时序攻击是一个看似矛盾的领域：理论上潜力巨大，似乎无所不能，但在现实中却难以奏效，实际应用很少，让人怀疑它是否只是一个“研究陷阱”。在刻意回避了十年后，作者最终决定亲自尝试研究时序攻击，并形容这个过程是“痛苦的”。他的具体研究目标是尝试通过时序攻击来回答一个困难的问题：判断目标网站的数据库中是否存在一个包含特定前缀的密码重置令牌。

In theory, if I try to guess a password reset token, then the time the application takes to compare my guess with the genuine token in the database should be measurably different, depending on how many characters I got correct. And so, using those measurements, I should be able to guess the secret token one character at a time, hijack arbitrary accounts on nearly any website, and generally have a good time.
这段文字阐述了针对密码重置令牌的时序攻击（Timing Attack）的​**理论原理**​。

核心观点是：

1. **攻击假设：** 当应用程序比较攻击者猜测的密码重置令牌和数据库中真实的令牌时，比较过程所花费的时间会​**根据猜测正确的字符数量（特别是从开头算起）而有所不同**​。
2. **利用方式：** 通过​**精确测量这些微小的时间差异**​，攻击者可以获得反馈。
3. **攻击方法：** 利用这种反馈，攻击者可以**逐个字符地猜测**出完整的秘密令牌。
4. **最终目标：** 一旦成功获取令牌，就能​**劫持任意用户的账户**​，理论上适用于很多网站。

​**总结来说**​：这段话描述了如何理论上利用服务器处理时间上的微小差异来逐步破解密码重置令牌，最终达到账户劫持的目的。

~~Now, I'd seen a write-up using this technique on a real website, but when I tried to replicate it, I discovered the write-up was actually completely theoretical. They never made a proof of concept to test if it really worked. So, I thought, "Okay, I'm going to build my own vulnerable system and hack that instead." And I built the system just fine, but the attack just would not work. So, I went hunting and found a lab that had been built by someone else to demonstrate this timing attack. And the attack worked really well on their lab. In fact, it worked so well that I became a little bit suspicious. And I decided to have a look at their source code and discovered that their string comparison function was not very realistic. The only reason that the attack worked was that they had injected this artificial sleep stamp.~~
这段文字描述了作者尝试将理论上的时序攻击（Timing Attack）付诸实践的过程及其发现：

1. **理论与现实脱节：** 作者看到一份声称在真实网站上成功利用时序攻击的报告，但自己尝试复现时发现，该报告完全是理论性的，作者并未实际验证过。
2. **自行尝试失败：** 作者决定自己构建一个（理论上）易受攻击的系统来测试这种攻击，虽然系统搭建成功，但时序攻击并未奏效。
3. **发现演示环境的“猫腻”：** 作者随后找到一个由他人构建的、专门用于演示时序攻击的实验环境（lab）。在这个环境中，攻击效果非常好。
4. **揭示真相：** 过好的效果让作者生疑。检查该环境的源代码后发现，其成功并非源于真实世界中字符串比较的微小时间差异，而是因为代码中被人为地加入了“延时”（artificial sleep stamp），这使得时间差异被人为放大，攻击才得以轻易成功。

**总结来说：** 作者通过亲身实践发现，理论上可行的时序攻击在实际中难以复现。并且，一些用于演示攻击成功的案例（如此处提到的lab）可能并非基于真实环境的微妙计时差异，而是通过人为修改代码（如加入延时）来简化攻击，这并不能代表真实世界的可行性。这突显了时序攻击理论与实践之间的巨大鸿沟。

~~At this point, I'd still gone nowhere. And as a last resort, I decided to cheat as much as possible and build a local benchmark that took tens of millions of measurements on my own system. And the attack still failed. So that seriously didn't work out. But what it did do was hammer this concept of the timing divide—the gap between the theoretical threat and the real threat, between the techniques that work inside someone's head, the techniques that work in an academic lab environment, and the techniques that actually work in the wild. No other web attack class has this kind of massive dramatic split between the theoretical and the practical. And the most interesting part of this split is the boundary between the two. If we zoom in on this boundary, then we can see that there's this huge gap, full of potentially undiscovered viable techniques. We know there's a cutoff somewhere in this range below which techniques don't work because the timing gap that they trigger is too small to measure. But where is that cutoff?~~
这段文字的大意是：

作者尝试进行一种（可能是基于时间的）网络攻击，即使在本地进行大量测试（作弊）也失败了。这次失败突显了一个关键概念：“时序鸿沟”（timing divide），即理论上可行的攻击技术与实际环境中（in the wild）真正有效的技术之间存在巨大差距。这种理论与实践的巨大分裂在其他类型的网络攻击中并不常见。作者认为，这个鸿沟的边界区域尤其值得关注，因为它可能隐藏着尚未发现但实际可行的攻击技术。目前已知存在一个阈值，低于该阈值的技术因引发的时间差过小而无法测量，从而无效，但这个确切的阈值（cutoff）在哪里尚不清楚。

**总结要点：**

1. 作者尝试的（基于时间的）攻击在实践中失败，即使在理想条件下。
2. 失败揭示了理论可行性与实际有效性之间的“时序鸿沟”。
3. 这种鸿沟在基于时间的攻击中尤为显著。
4. 鸿沟的边界地带可能存在未被发现的有效攻击技术。
5. 确定使攻击技术变得实际可行的精确阈值是一个悬而未决的问题。

~~Well, during this piece of research, the smallest time difference that led me to a real finding on a live system was 200 microseconds—that's 0.2 milliseconds. So, we've got a lot to cover. I'm going to start by showing how to make timing attacks that work everywhere. Targeting one system is okay, but targeting arbitrary systems with no configuration required is a lot more fun. Then, I'm going to introduce three novel timing attack techniques. Each of which has been tested on tens of thousands of live websites that have bug bounty programs. They're all proven with real-life case studies from those targets, and they're all accompanied by automated open-source tooling, leaving you equipped to apply all these techniques for yourself next time you look at a website. After that, I'll launch the CTF chat defense, and then wrap up, leaving five minutes for questions.~~
这段文字的大意是：

作者接着前面的讨论，给出了一个具体的**成功案例**：在实际线上系统中，他们发现的最小能导致**真实发现**（real finding）的时间差是 **200 微秒**（0.2 毫秒）。

然后，作者概述了接下来要分享的内容（可能是一场演讲或研究报告）：

1. **演示通用性时序攻击**：介绍如何构建**无需特定配置**、能在任意系统上生效的时序攻击。
2. **介绍三种新的时序攻击技术**：
   * 这些技术是**新颖的** (novel)。
   * 已在**数万个**设有漏洞赏金计划（bug bounty programs）的**真实网站**上进行了测试。
   * 有来自这些目标的**真实案例研究** (real-life case studies) 作为证明。
   * 配有**自动化的开源工具**，让听众/读者能够自己应用这些技术。
3. **后续安排**：之后会启动 CTF（夺旗赛）相关的活动，然后总结并留出 5 分钟提问时间。

**总结要点：**

* 作者找到了一个实际可行的时序攻击阈值下限的**实例**（200 微秒）。
* 将重点介绍**通用**且**新颖**的时序攻击技术。
* 这些技术经过了**大规模实战验证**，并有**工具支持**，旨在让其他人也能**实际应用**。
* 最后概述了演示/报告的后续流程。

~~So, how do you make timing attacks that work everywhere? Well, timing attack success comes down to the balance between two variables: the signal, which is the size of the delay that you're trying to measure, and noise, which is everything else that affects the response time. If the signal is too quiet relative to the background noise, you won't hear it, and the attack will fail. Now, you can split noise into two parts: network jitter and internal jitter. Network jitter is already absolutely notorious for making timing attacks fail. When someone sees a timing attack demonstrated against a local system and says, "That will never work on a real remote target," they're basically saying network jitter will make that attack impossible. And five years ago, that might have been true. But with HTTP/2, network jitter is dead. Web timing attacks are effectively now local because, in 2020, a paper called "Timeless Timing Attacks" showed that HTTP/2 concurrency features mean you can place two requests into a single TCP packet, and they'll get processed at the same time, effectively eliminating the harmful impact of network jitter on timing attacks.~~
​**这段文字解释了**如何让时序攻击在各种环境下（特别是远程）都能有效工作**。**

​​​**核心在于处理好**信号**（要测量的时延大小）和**噪音**（影响响应时间的其他因素）之间的平衡。如果信号相对于噪音太弱，攻击就会失败。**

​​**噪音可分为**网络抖动 (network jitter)** 和内部抖动。其中，**网络抖动**一直被认为是导致时序攻击（尤其是在远程目标上）失败的主要原因。**

​​**然而，作者指出，**由于 HTTP/2 的出现，网络抖动问题已基本解决 (“dead”)**。根据 2020 年一篇名为 "Timeless Timing Attacks" 的论文，HTTP/2 的并发特性允许将两个请求放入**同一个 TCP 数据包**中，使它们几乎同时被处理。这**有效地消除了网络抖动对时序攻击的负面影响**。**

​​​**因此，现在的 Web 时序攻击**实际上（effectively）接近于本地攻击**，大大提高了在真实、远程目标上成功的可能性。**

​**总结要点：**

* ​**时序攻击成功的关键是**信号强于噪音**。**
  
  ​
* **网络抖动**是传统上阻碍远程时序攻击的主要噪音来源。
* **HTTP/2 的并发特性**通过将多个请求打包处理，**有效消除了网络抖动**的影响。
* ​**这使得 Web 时序攻击在远程目标上的可行性**大大提高**，效果接近本地攻击。**
  
  ​

~~That by itself is absolutely huge. But during this research, I realized we can do even better because there is one catch with that technique, and it's called the sticky ordering problem. Because both requests are on one TLS stream, one of them has to come before the other. And virtually all websites and all web servers have a bias towards processing and responding to the first request first. The authors addressed this by adding extra query parameters to the first request so that it takes longer to process that one. And in theory, things get back in sync. But this approach has issues that make it unsuitable for use on many targets in the wild. What we need is a universal solution, and we almost already have one because last year I developed a single packet attack, which withholds a tiny fragment of each request and places that in the final packet. The idea is that the last packet is what triggers processing. And by only putting a tiny fragment there, you can complete 20 requests with the final packet, which is great for triggering race conditions. But coincidentally, if you only put two request fragments in the final packet, that makes it really small, which means the TLS decryption size is reduced, and that helps fix the sticky ordering problem.~~
**这段文字的大意是：**

​​**尽管利用 HTTP/2 并发特性消除网络抖动（如 "Timeless Timing Attacks" 论文所述）是巨大的进步，但作者发现该技术存在一个**缺陷**，称为“**粘性排序问题**”（sticky ordering problem）。**

​​​**这个问题是：即使两个请求在同一个 TCP 包（或 TLS 流）中，其中一个请求在逻辑上仍然排在另一个之前，而大多数服务器倾向于**优先处理并响应先到达的那个请求**，这破坏了完全同步处理的理想状态。**

​**原论文尝试通过人为增加第一个请求的处理时间来解决此问题，但这并非**通用**的解决方案，在实际应用中存在局限性。**

​​**作者随后提出了一种**更优的、更通用的解决方案**，基于他们之前开发的“**单包攻击**”（single packet attack）技术：**

​​* ​**该技术原本设计用于触发竞争条件，通过将多个（例如 20 个）请求的**微小片段**（tiny fragment）扣留，放在**最后一个数据包**中发送。这个最后的数据包会同时触发所有这些请求的处理。**

​

* ​**作者发现，如果**只将两个请求的微小片段**放在最后一个数据包中，这个包会变得**非常小**。**
  
  ​
* **包变小**意味着最终的 TLS 解密工作量减少，这有助于**缓解或修复**前面提到的“粘性排序问题”，使得两个请求的处理时机更加接近同步。

**总结要点：**

* **标准 HTTP/2 并发技术虽能消除网络抖动，但存在“粘性排序问题”（服务器处理有先后偏向）。**
* **原论文的解决方案不通用。**
* **作者提出改进方案：利用“单包攻击”思想，将两个请求的最后小片段放在一个极小的最终包里发送。**
* ​**这个小包有助于减少 TLS 解密开销，从而**更有效地解决粘性排序问题**，使时序攻击技术更加健壮和通用。**
  
  ​

~~Unfortunately, this technique is not quite generic because some major web servers, like Nginx, start processing request fragments the moment they see the HTTP headers. And what that does is it completely makes this technique behave terribly on those targets. Some of these web servers will even reply to your request before you finish sending it. To handle these systems equally well, what we need to do is coalesce all the request headers into a single packet as well. So this way, we've got two synchronized packets, and whether the server waits for the last one or starts processing on the first one, we get synchronized execution and a high-accuracy timing attack.~~
这段文字的大意是：

作者指出，之前提到的利用“单包攻击”发送两个请求的微小片段来解决粘性排序问题的方法，**仍然不够通用**。

原因是，像 Nginx 这样的一些**主流 Web 服务器**，在**收到请求头（headers）时**就会开始处理请求片段，而不是等待整个请求（包括最后的微小片段）完成。这种**“提前处理”的行为**破坏了依赖最后小包触发同步处理的机制，导致该技术在这些目标上效果很差，甚至可能在请求发送完毕前就收到响应。

为了**真正实现通用性**，处理好这些“提前处理”的服务器，作者提出了**进一步的改进**：不仅要将最后的请求片段放在一个同步包中，还**需要将两个请求的所有请求头也合并（coalesce）到另一个单独的同步包中**。

这样一来，就有了**两个同步的数据包**：一个包含所有头部，一个包含最后的片段。无论服务器是等待最后一个包才开始处理，还是在收到第一个包（头部）时就开始处理，都能确保两个请求的**执行是同步的**。

最终目标是实现**高精度的、适用于各种服务器行为的时序攻击**。

**总结要点：**

1. 之前基于“最后小片段包”的同步技术对 Nginx 等提前处理请求头的服务器效果不佳。
2. 为了解决这个问题，需要将**请求头**也进行同步处理。
3. 最终方案：将**两个请求的头部**合并放入一个同步包，将**两个请求的最后片段**放入另一个同步包。
4. 这种“**双同步包**”策略确保了无论服务器处理机制如何（早处理或晚处理），都能实现请求的**同步执行**，从而达成通用的高精度时序攻击。

~~Making this happen turned out to be extremely easy. All you have to do is take what we've got here, which is the algorithm for the original single packet attack, and add an extra ping frame, this initial sacrificial packet. Uh, yeah, I found this by accident, as you can probably guess. What it does is it acts as a clue to the operating system that we'll be sending a bunch of packets imminently, and it's time to start coalescing things. This simple change made the technique twice as accurate on my Nginx test bed. And this enhanced version is already available in Burp Suite, in both the free and pro versions. I'm working with the maintainer of the open-source alternative, H2 SpaceX, to get it there, and I think it will be published there this week.~~
**这段文字的大意是：**

​​**作者发现，实现上一段提出的“**双同步包**”（同步头包+同步尾片段包）策略以获得通用高精度时序攻击的方法，**出人意料地简单**。**

​​​**具体做法是：在原有的“单包攻击”算法基础上，在发送实际请求包之前，先发送一个**额外的“ping”帧**（或称为“初始牺牲包”）。**

​​​**这个“ping”帧的作用是**提示操作系统**（OS）的网络栈，即将有**一批数据包**紧随其后发送，从而**触发操作系统开始合并（coalescing）后续的数据包**。这种由操作系统层面的包合并，自然地帮助实现了将请求头和请求尾部分别放入同步包中发送的效果。**

​​​**作者提到这是**意外发现**的，但这个简单的改动在他们的 Nginx 测试环境中，将**技术的准确性提高了一倍**。**

​​**最后，作者指出，这个**增强版的技术**：**

​* **已经集成到 **Burp Suite** 的免费版和专业版中。**

* **正在与开源替代工具 **H2 SpaceX** 的维护者合作，预计本周内也会在该工具中发布。**

**总结要点：**

* **实现通用高精度时序攻击（处理 Nginx 等提前处理服务器）的方法很简单。**
* ​**只需在发送请求前加一个**初始的“ping”帧**。**
  
  ​
* ​**这个“ping”帧能**触发操作系统的网络包合并机制**，从而实现所需的同步发送效果。**
  
  ​
* ​**此方法显著提高了技术在 Nginx 等服务器上的**准确性**（提高一倍）。**
  
  ​
* ​**该增强技术已在 **Burp Suite** 中可用，并将很快加入 **H2 SpaceX**。**
  
  ​

~~So now we've solved network noise. That just leaves server noise, which should not be underestimated. This can come from many places, including load on the target server, load on other systems the target is interacting with, and even other virtual systems running on the same physical hardware, which is super common in cloud environments.~~
**这段文字的大意是：**

​​​**在解决了**网络噪音**（network noise）问题之后，时序攻击仍然面临**服务器噪音**（server noise）的挑战，并且**这种噪音不应被低估**。**

​​​​**服务器噪音的来源**多种多样**，包括：**

​* ​**目标服务器自身的负载**。

​

* ​**目标服务器**与之交互的其他系统**（如数据库、后端服务等）的负载。**
  
  ​
* ​**运行在**同一物理硬件上的其他虚拟系统**（在云环境中非常普遍）所带来的干扰。**
  
  ​

**总结要点：**

* **解决了网络噪音后，**服务器噪音**成为影响时序攻击准确性的主要障碍。**
* ​**服务器噪音来源广泛，包括**目标自身负载、依赖系统负载**以及**共享硬件环境（云环境）中的干扰**。**
  
  ​
* ​**强调了**服务器噪音的重要性**，不能忽视。**
  
  ​

~~The best way to tackle server noise is to accept it. It's just going to be there. And amplify the signal so that the signal still stands out. For example, say that you want to use that string comparison attack concept to test if there's a header name starting with "X-Hyphen-U." Then, instead of sending that header prefix once, send it a few hundred times with the same prefix. And that will cause a delay that's several hundred times easier to detect. And that might actually work on a real server. You can take things even further than that and adopt a denial-of-service mindset, using techniques like nested XML entities, graph cure Bing, and regular expression denial of service to create a massive signal that will stand out through any server noise.~~
**这段文字的大意是：**

​​​​**应对**服务器噪音**（server noise）的最佳策略不是试图消除它，而是**接受它的存在**，并通过**放大信号**（即要测量的时延）来让信号在噪音中**脱颖而出**。**

​​​​**作者给出了两种放大信号的方法：**

* ​**重复操作**：以探测以 "X-Hyphen-U" 开头的标头为例，不要只发送一次，而是发送**数百次**带有相同前缀的标头。这样产生的总延迟会增大数百倍，从而更容易被检测到，可能在真实服务器上奏效。
  
  ​
* ​**采用 DoS（拒绝服务）思维**：更进一步，使用已知能造成显著处理延迟的技术，例如：
  
  ​* **嵌套 XML 实体（Nested XML entities，可能指 XXE 或 Billion Laughs 攻击）**
  
  * **GraphQL 复杂查询（原文 "graph cure Bing" 可能是 GraphQL 的误写或特定术语）**
  * **正则表达式拒绝服务 (ReDoS)**
  
  ​​**这些技术旨在**制造一个巨大的信号**（非常大的时间延迟），使其强大到足以**压倒任何服务器噪音**。**
  
  ​​

**总结要点：**

* ​**处理服务器噪音的核心方法是**放大信号**，而非消除噪音。**
  
  ​
* **可以通过**多次重复**触发时间延迟的操作来放大信号。**
* ​​**更极端的方法是利用 **DoS 类技术**（如嵌套 XML、复杂 GraphQL 查询、ReDoS）制造**巨大的时间延迟**，确保信号能被清晰测量。**
  
  ​​

~~Ultimately, a denial-of-service is just a really easy timing attack. On the flip side, you can try to reduce the noise on the server. This is less effective in general, but it works sometimes. And the approach that I found that tends to work is embracing performance features like caching. The concept here is that the less time the server spends processing your request, the less time it has to accumulate noise that will then make your measurement fail to reveal anything useful. So, if you send requests with the same values multiple times, that can trigger caching, which can help. And you can also try to shorten the code path by doing things like chopping out session cookies if they're not required. Or in some cases, you might even add things like, hypothetically, if you add a "Do Not Track" header, that might bypass some analytics code on the server, thereby making your attack more accurate. Of course, we all know everyone ignores that header.~~
**这段文字的大意是：**

​**除了放大信号，另一种应对服务器噪音的方法是尝试**减少服务器端的噪音**本身，虽然这种方法通常**效果不如放大信号**，但有时也有效。**

​​**作者发现一种**可行的减少噪音的策略**是**利用服务器的性能优化特性，特别是缓存（caching）**。**

​* ​**核心理念**：服务器处理请求的时间越短，累积可能干扰测量的噪音的时间就越少。

​

* ​**触发缓存的方法**：多次发送具有相同值的请求。
  
  ​
* ​**其他减少噪音（缩短处理路径）的方法**：
  
  ​* **如果不需要，**移除会话 Cookie** 等非必需数据。**
  
  * **添加可能**触发代码路径捷径**的元素。例如（虽然作者也指出了其现实局限性），添加 "Do Not Track" 标头**可能**会使服务器跳过某些分析代码，从而减少处理时间和噪音，提高攻击精度。**

**总结要点：**

* ​**作为放大信号的补充/替代方法，可以尝试**减少服务器噪音**。**
  
  ​
* **主要方法是利用**缓存**等性能特性，**缩短服务器处理时间**以减少噪音累积。**
* **可以通过**重复发送相同请求**来触发缓存。**
* ​​**也可以通过**简化请求**（移除非必需部分）或添加特定元素（如 DNT 头，理论上）来**缩短服务器处理路径**，从而减少噪音。**
  
  ​​
* ​**作者也暗示了减少噪音策略的**局限性**（不如放大信号有效，DNT 头常被忽略）。**
  
  ​

~~So those techniques make timing attacks reliable and also fast. I only sent five request pairs to most targets for each technique in this research, going up to 50 to compare and confirm promising findings. As far as the actual response order and response timing analysis goes, Param Miner will take care of everything for you. But if you prefer to experiment, you can do that with Turbo Intruder, which will give you output that looks something like this. The main thing to note here is that when you're using HTTP/2 with a single packet attack, you want to be looking at the response order. And when you're using HTTP/1, you're just going to be using the timing, so you need to look at the response ranges.~~
**这段文字的大意是：**

​**前面讨论的技术（结合消除网络噪音和应对服务器噪音）使得时序攻击变得**可靠且快速**。作者在研究中，对大多数目标通常**只需要发送 5 对请求**就能进行初步探测，最多用 50 对请求来确认有潜力的发现，这体现了技术的效率。**

​**在**分析响应结果**方面：**

* ​**自动化工具**：**Param Miner** 可以自动处理响应顺序和响应时间的分析工作。
  
  ​
* ​​**手动实验工具**：如果想自己实验和分析，可以使用 **Turbo Intruder**，它会提供详细的原始输出。
  
  ​​
* ​**关键分析指标**：
  
  ​* ​​**当使用 **HTTP/2**（特别是结合“单包攻击”技术）时，重点关注**响应的顺序**。**
  
  ​​
  
  * ​**当使用 **HTTP/1** 时，由于没有可靠的同步机制，主要关注**响应时间的范围/差异**。**
    
    ​

**总结要点：**

* ​**所述技术使时序攻击**可靠且高效**（所需请求少）。**
  
  ​
* **Param Miner** 可自动分析结果。
* **Turbo Intruder** 可用于手动实验和分析。
* ​**分析方法**取决于使用的 HTTP 版本：**HTTP/2 关注响应顺序，HTTP/1 关注响应时间**。
  
  ​

~~The other thing to note here is that these two attacks were both trying to spot the same 0.5-millisecond delay on the same server. And as you can see, the single packet attack detected it very, very comfortably, whereas the time analysis failed spectacularly. So obviously, whenever they support HTTP/2, the single packet attack is the way to go. That is the foundation of timing attacks that work everywhere. The part that there's no formula for is choosing the question that you want to answer.~~
**这段文字的大意是：**

​**作者通过一个具体的**对比实验**强调了前面讨论的技术（特别是基于 HTTP/2 的“单包攻击”）的**优越性**。**

​* ​**实验设置**：在同一服务器上，使用两种不同的攻击方法尝试检测**同一个 0.5 毫秒**的微小时间延迟。

​

* ​**实验结果**：
  
  ​* ​**“**单包攻击**”（Single Packet Attack，利用 HTTP/2）**非常轻松、清晰地**检测到了这个延迟。**
  
  ​
  
  * ​​**传统的“**时间分析**”（Time Analysis，可能基于 HTTP/1 或未优化的 HTTP/2）则**完全失败**。**
    
    ​​
* ​​**结论**：只要目标服务器支持 **HTTP/2**，就应该\*\*优先选择“单包攻击”\*\*技术。
  
  ​​
* ​​​**核心地位**：这种方法被认为是构建“**能在任何地方生效的时序攻击**”（timing attacks that work everywhere）的**基础**。
  
  ​​​
* ​​**待解决的关键问题**：尽管有了可靠的测量技术（如何攻击），但**选择用这个技术去探测什么具体信息或漏洞**（即“要问的问题”）是没有固定公式或方法的，是实践中的难点。
  
  ​​

**总结要点：**

* **实验证明，基于 HTTP/2 的“单包攻击”在检测微小时间差方面**远优于**传统方法。**
* ​**推荐在支持 HTTP/2 的目标上使用“单包攻击”**。
  
  ​
* ​**该技术是实现**通用、可靠时序攻击的基础**。**
  
  ​
* ​**时序攻击成功的**关键挑战**在于**确定攻击目标或要探测的具体问题**，而非技术本身。**
  
  ​

~~I started my research by using timing for parameter discovery. Vulnerabilities often lurk out of sight in overlooked or forgotten features that can only be accessed via hidden parameters. To discover those, you might use a tool like Param Miner, which guesses parameter names or header names and then looks at the response to see if they did anything. That means if a valid parameter doesn't change the response, you won't detect it, and you'll miss the exploit. So for my first bulk timing attack, I decided to fix this by making Param Miner look at the response time as well as the response contents. And then I just ran that on a pipeline of 20,000 sites. And to my surprise, this really worked. It revealed tons of parameters and headers that I would never have found otherwise, including some completely crazy ones like a web server that takes an HTTP header called "CommonConfig," and it's revealed by a 5-millisecond delay, which is triggered by adding the header unless the header value is valid JSON.~~
**这段文字的大意是：**

​**作者将之前讨论的通用时序攻击技术应用于**参数发现**（parameter discovery）领域，以解决现有工具的局限性。**

​* ​**问题**：传统的参数发现工具（如 Param Miner）主要通过猜测参数/标头名称，并观察**响应内容**是否变化来判断其有效性。这种方法会**遗漏**那些虽然有效但**不改变响应内容**的“隐藏”参数或标头，从而可能错过潜在的漏洞。

​

* ​​**解决方案**：作者改进了参数发现方法，使其**同时分析响应时间和响应内容**。
  
  ​​
* ​​**实践应用**：作者将这种基于时间的参数发现技术应用于**20,000 个网站**。
  
  ​​
* ​​**结果**：该方法**非常成功**（"really worked"），发现了大量仅凭内容变化无法找到的参数和标头。
  
  ​​
* ​​**具体案例**：发现了一个名为 "CommonConfig" 的 HTTP 标头。当此标头存在**且其值不是有效的 JSON** 时，会触发一个 **5 毫秒的延迟**，从而被时序攻击检测到。这表明服务器对该标头进行了某种处理（可能是 JSON 解析），其处理时间随值的有效性而变化。
  
  ​​

**总结要点：**

* ​**作者将时序攻击应用于**参数发现**，以弥补传统内容分析方法的不足。**
  
  ​
* ​**通过**结合响应时间和内容分析**，可以发现那些不改变响应内容但影响处理时间的隐藏参数/标头。**
  
  ​
* ​**在**大规模测试（20,000 个网站）中验证了该方法的有效性**。**
  
  ​
* **成功发现了一个通过 **5ms 时间延迟**揭示的 "CommonConfig" 标头，该延迟与标头值的 JSON 有效性相关。**

~~On another site, I was able to detect a header even though they never actually sent me a response ever. They always reset my connection, but they took longer to reset the connection if I sent a certain header. I think it might have been "Authorization," but I didn't write down the header name at the time, so I'm not sure. It also detects some really useful things. Here's one of them. What do you think is happening here? When you see a massive time gap like this, that can indicate a cache. In this example, we can see changing the value of the "ID" parameter is causing a cache miss, and changing the value of an arbitrary other parameter is not. We're getting a cache hit and a fast response. That tells us that they're only including certain parameters in the cache key, which means two things: one, they're really likely to be vulnerable to cache poisoning vulnerabilities because this type of configuration is extremely dangerous and hard to get right. Secondly, clearly, they've added the "ID" parameter to this key explicitly. So that means it's highly likely that that website supports a parameter called "ID" somewhere on that site. In other words, with timing, you can sometimes detect parameters on different pages.~~
**这段文字的大意是：**

**作者继续列举**基于时间的参数/标头发现**的更多成果和应用场景：**

* ​​**即使没有正常响应也能发现标头**：在一个案例中，服务器总是重置连接，但如果发送了某个特定标头（作者推测可能是 "Authorization"），**重置连接所需的时间会更长**。这表明即使没有收到响应内容，时间差异也能揭示标头的存在和影响。
  
  ​​
* ​**利用时间差异检测缓存行为**：
  
  ​* ​​​**观察到一个**巨大的时间差**：当改变特定参数（如 "ID"）的值时，响应**变慢**（可能是缓存未命中）；而改变其他任意参数时，响应**很快**（缓存命中）。**
  
  ​​​
  
  * ​​**推断**：这表明服务器的缓存机制**只将某些特定参数（如 "ID"）纳入了缓存键 (cache key)**。
    
    ​​
  * ​**两个重要启示**：
    
    ​* ​**缓存投毒风险 (Cache Poisoning)**：这种选择性缓存键的配置非常危险，极易受到缓存投毒攻击。
    
    ​
    
    * ​​**跨页面参数发现**：由于 "ID" 参数被显式地加入缓存键，即使当前测试的页面不直接使用 "ID"，这也强烈暗示了该网站的**其他地方**确实支持和使用了名为 "ID" 的参数。因此，时序分析有时能**检测到在网站不同页面上使用的参数**。
      
      ​​

**总结要点：**

* ​**时序攻击可以在**非标准响应场景**（如连接重置）下发现参数/标头。**
  
  ​
* ​**巨大的时间差异通常可以**指示缓存机制的存在**。**
  
  ​
* ​**通过分析不同参数变化对响应时间的影响，可以推断出**缓存键的组成**。**
  
  ​
* ​**选择性的缓存键配置不仅**增加了缓存投毒的风险**，还使得通过时序分析**发现网站其他页面使用的参数**成为可能。**
  
  ​

~~The challenge in this research came from somewhere completely unexpected: time analysis is too powerful because almost everything causes a time difference. It's really easy to let your own assumptions lead you to the wrong conclusion. And to illustrate this, because you might find that hard to believe, I'm going to do a live demo. And in the spirit of this presentation, I'm targeting a live remote system. Here, as you can see, we've got a request to a website that I have redacted because it's a live system. I don't control it. I don't even know what country it's in. And if we send this a few times, so I'm going to read out the time that's in the bottom right here because it's probably too small for you to see. So we're getting this response in about 160 milliseconds, about 165 on average.~~
**这段文字的大意是：**

​​​​**作者指出了**时序分析研究中的一个意外挑战**：时序分析技术**过于敏感**（"too powerful"），因为**几乎任何变化都会导致时间差异**。这使得研究人员**很容易被自己的假设误导**，从而得出错误的结论。**

​​​​​​**为了**证明这一点**（即时间差异无处不在，易于误判），作者准备进行一个**现场演示**（live demo）。**

​​* ​**演示目标**：一个**真实的、远程的**系统，作者对其没有控制权，甚至不知道其具体位置（网站已被隐去名称）。

​

* ​​**演示步骤（初始）**：向该目标发送一个请求数次，并记录响应时间，建立一个**基线**。
  
  ​​
* ​**初始结果**：响应时间大约在 **160-165 毫秒**左右。
  
  ​

**这个演示的目的是为了后续展示某个变化引起的时间差异，并说明为何需要谨慎解读这种差异，避免因过多“噪音”信号而做出错误判断。**

**总结要点：**

* ​**时序分析的主要挑战在于其**高度敏感性**，易于产生大量时间差异信号。**
  
  ​
* **这导致研究人员**容易基于假设错误地解读**这些时间差异。**
* ​**作者将通过**现场演示**（针对真实远程系统）来说明这个问题。**
  
  ​
* ​**演示首先建立了目标的**基线响应时间**（约 165 毫秒）。**
  
  ​

~~Now, what Param Miner noticed is that if you send a parameter called "exec," and you send that, then the response now takes about 175 milliseconds. It's taking about 10 milliseconds longer to send us this response. So at first glance, you might think that maybe this target has a little backdoor and it's trying to execute that as a shell command, and we've got unauthenticated remote code execution on this server. However, that is sadly not the case. One clue is that if you try to send a payload like this, uh, old-school Shellshock payload here, the server resets the connection. It may reset the connection. It's not responding. That's not supposed to happen anyway. You get the gist. There's something funny happening when we send this payload, right? I wonder what happens if I do it again. Who knows? Anyway, I hope that server hasn't just gone down.~~
​**这段文字继续描述了作者正在进行的**现场演示**，旨在说明**时序分析结果容易被误解**的问题。**

​* ​**演示步骤（加入变化）**：作者在之前的请求中添加了一个名为 **"exec"** 的参数 (**?exec=**) 并发送。

​

* ​​​**观察到的时间变化**：添加该参数后，响应时间增加到约 **175 毫秒**，比基线长了大约 **10 毫秒**。
  
  ​​​
* ​**初步（错误的）假设**：仅凭这个时间延迟，人们**可能轻易地推断**服务器尝试将 **exec** 参数的值作为命令执行，暗示存在**未经身份验证的远程代码执行 (RCE)** 漏洞。
  
  ​
* ​​**证伪过程**：作者接着尝试发送一个**实际的命令执行 payload**（一个经典的 Shellshock payload）。
  
  ​​
* ​**实际结果**：服务器对包含 payload 的请求反应异常，**重置了连接**或根本不响应（演示中似乎出了点小意外，但核心点是服务器行为异常且并非成功执行命令）。
  
  ​
* ​**结论**：最初基于 10 毫秒延迟推断出的 RCE 漏洞**并不存在** ("sadly not the case")。服务器对包含特定 payload 的 **exec** 参数的反应（连接重置/无响应）与简单的 RCE 不符。
  
  ​

**这个演示成功地说明了作者之前的观点：**检测到时间差异很容易，但准确解释其原因并避免错误结论（如误判为 RCE）则需要谨慎和进一步验证。** 那个 10 毫秒的延迟确实存在，但它是由其他原因引起的，而不是命令执行。**

~~So that's one clue. The other clue that something a bit funny is happening is that we also see this time delay with certain other parameter names like "eval." So what's actually happened here is this is a web application firewall, and what's happening is when it sees a parameter called "exec," it thinks, "That looks suspicious. I'm going to do some extra processing on this request," and that's what's causing the delay that we observed. I'm just going to send one more request to see if this target's up. It is. Great.~~
​**这段文字揭示了之前演示中观察到的 **10 毫秒时间延迟的真正原因**，并进一步强调了**时序分析结果易被误解**的观点。**

​* ​**第一个线索**（来自上文）：尝试发送实际的 RCE payload 失败（连接重置/无响应）。

​

* ​​​**第二个线索**：作者发现，不仅仅是 "exec" 参数，使用其他**可疑的参数名称**（如 "eval"）也会引发**类似的时间延迟**。
  
  ​​​
* ​​**真正的原因**：目标系统部署了一个**Web 应用防火墙 (WAF)**。
  
  ​​* **当 WAF 检测到像 "exec" 或 "eval" 这样**看起来可疑**的参数名称时，它会认为这可能是攻击尝试。**
  
  * ​**因此，WAF 会对这些请求进行**额外的、更深入的处理和检查**。**
    
    ​
  * ​**正是这个**额外的处理过程**导致了观察到的 **10 毫秒延迟**。**
    
    ​
* ​**结论**：时间延迟并非由服务器尝试执行命令引起，而是由 **WAF 的安全防护机制**触发的。这再次证明了仅凭时间差异就下结论（如 RCE）是不可靠的，必须结合其他线索和深入分析。
  
  ​

**作者最后还确认了一下目标服务器仍然在线。**

**总结要点:**

* **观察到的时间延迟（使用 "exec" 或 "eval" 参数时）是由 **WAF** 引起的。**
* ​**WAF 将这些参数名识别为潜在威胁，并对其进行**额外的安全处理**，从而增加了响应时间。**
  
  ​
* ​**这有力地说明了时序分析的**敏感性**和**误报可能性**：检测到的时间差需要谨慎解释，不能直接等同于特定漏洞（如 RCE）。**
  
  ​
* ​**需要结合**多种线索**（如 payload 测试、对其他相似输入的反应）来判断时间差异的真正原因。**
  
  ​

~~Okay, so you might think, "Okay, it's a false positive. Let's give up on this target and move on." But personally, I was intrigued. I wanted to know, "Well, okay. If we send this once and they do extra processing and it causes a delay, what happens if we send it ten times?" And the answer is this response is now taking 300 milliseconds to come back. We've slowed it down by like an extra 200 milliseconds. So the next logical question from here is, "Well, how many times can we specify this, right? Because presumably, they're thrashing their CPU analyzing this request. And if we specify it quite a few times, then maybe we can trigger a denial of service."~~
**这段文字的大意是：**

**作者认为，即使发现时间延迟是由 WAF（Web 应用防火墙）引起的，而不是最初猜测的 RCE，也不应简单地将其视为**误报 (false positive)** 而放弃。**

​**相反，作者对此产生了**兴趣**，并提出了进一步的问题：**

​* **重复触发会怎样？** 如果发送一次 "exec" 参数导致额外处理和延迟，那么发送**十次**会发生什么？

* ​​​**实验结果**：发送十次 "exec" 参数后，响应时间增加到 **300 毫秒**，比发送一次（约 175 毫秒）又慢了大约 125 毫秒（作者说“额外 200 毫秒”，可能指相对于基线 165 毫秒增加了约 135 毫秒，或相对于单次 exec 请求增加了约 125ms，重点是显著增加）。这表明**延迟效应可以被放大**。
  
  ​​​
* ​​**进一步的推论和潜在攻击方向**：基于延迟可以被重复放大的观察，作者提出了下一个逻辑问题：可以指定这个参数**多少次**？
  
  ​​
* ​​**潜在目标**：作者推测，重复指定该参数可能会使 WAF/服务器的 **CPU 资源耗尽**（"thrashing their CPU"），因为需要反复进行分析。如果能指定足够多次，或许就能触发**拒绝服务 (Denial of Service, DoS)** 攻击。
  
  ​​

**总结要点:**

* **不应轻易放弃由 WAF 等机制引起的时间延迟，它们可能隐藏其他机会。**
* **重复发送触发 WAF 额外处理的参数，可以**显著放大**时间延迟。**
* **这种延迟放大表明处理负载增加，并引出了**利用此机制进行 DoS 攻击**的可能性。**
* **将看似“误报”的发现转化为潜在的 **DoS 漏洞**调查方向。**

~~Uh, so if I send this, you will see this does, in fact, take a very long time for the server to process. So it took just under 3 seconds. I'll just send this a couple more times. So we add 2.8 seconds, 3.1 seconds, and 3.1 seconds. So now great. That's a nice denial-of-service vector. But there's something even more interesting here because if I just add this parameter a couple of extra times and then send it again, then the response has come back in 2.6 milliseconds. The response has come back 300 milliseconds faster. So now, just through timing, we've learned something else, which is that when we add this extra couple of parameters, we go over some kind of threshold, and clearly, we've hit some kind of different code path.~~
​**这段文字描述了作者继续探索之前发现的 WAF 行为，并得到了**两个关键发现**：**

​* ​**确认了 DoS 向量**：

​* ​​**作者通过发送包含**大量重复 "exec" 参数**的请求，成功地使服务器响应时间**显著增加**，达到了接近 **3 秒**（2.8s, 3.1s）。**

```
​​
```

* ​**这证实了之前的推测：利用 WAF 对可疑参数的额外处理机制，确实可以发起有效的**拒绝服务 (DoS) 攻击**。**
  
  ​
* ​**发现了更深层的行为——阈值和不同代码路径**：
  
  ​* ​​**意外发现**：当作者在已有的“大量”参数基础上，**再额外增加几个 "exec" 参数**时，服务器的响应时间**骤降**至 **2.6 毫秒**。
  
  ​​
  
  * ​​​**重要推断**：这个现象表明，当重复参数的数量**超过某个阈值**后，WAF 或服务器触发了**不同的处理逻辑（代码路径）**。这个新的代码路径显然**更快**，可能是一种快速失败、直接拒绝或简化的处理机制，而不是之前那种耗时的深度分析。
    
    ​​​
  * ​​​**意义**：仅仅通过**观察时间变化**，就揭示了目标系统内部存在的**处理阈值**和**条件分支逻辑**，这是更深层次的信息。
    
    ​​​

**总结要点:**

* ​**重复发送触发 WAF 额外处理的参数，可以成功造成 **DoS**（响应时间达 3 秒）。**
  
  ​
* **但当参数数量**超过某个阈值**后，系统行为发生突变，响应时间**急剧下降**至毫秒级。**
* ​​**这表明存在一个**内部处理阈值**，超过该阈值会触发**不同的、更快的代码路径**。**
  
  ​​
* ​**这个例子再次证明了**时序分析的强大之处**：它不仅能发现简单的延迟，还能揭示系统内部复杂的处理逻辑和阈值行为。**
  
  ​

~~So the next logical question now is, "Well, if they're responding faster, maybe they're doing less analysis on our request. So maybe if we put this payload here that just causes a connection reset or makes the server timeout, they will let the payload get through." It did when I practiced this. There we go. So using nothing but timing analysis, we found a complete bypass for this web application firewall. That's really quite powerful, and it shows how you can use timing to reverse-engineer the service operation.~~
​​**这段文字描述了作者如何利用前面发现的 **WAF 处理阈值和快速代码路径**，最终实现了 **WAF 绕过**。**

​​* ​​**新的假设**：既然超过某个阈值后服务器响应变快，这可能意味着 WAF 在这种情况下**执行的分析减少了**。

​​

* ​**测试策略**：基于这个假设，作者尝试将之前**导致连接重置或超时的恶意 payload** 与**足够多（超过阈值）的 "exec" 参数**一起发送。目的是看在这个“快速（可能审查不严）”的代码路径下，该 payload 是否能成功通过 WAF。
  
  ​
* ​**结果**：**测试成功** ("It did when I practiced this. There we go.")。之前被 WAF 拦截的 payload，在触发了快速代码路径后，成功地通过了 WAF。
  
  ​
* ​​​**重大意义**：仅仅通过**分析响应时间的变化**（时序分析），作者不仅发现了 WAF 的内部处理逻辑（阈值、不同代码路径），还最终找到了一个**完整的 WAF 绕过方法**。
  
  ​​​
* ​​**结论**：这个案例有力地证明了时序分析的强大能力，它不仅能检测简单延迟，还能用于**逆向工程服务器/WAF 的操作逻辑**，并发现严重的安全漏洞（如 WAF 绕过）。
  
  ​​

**总结要点:**

* ​**作者推断 WAF 的快速响应路径可能对应着**较少的安全分析**。**
  
  ​
* ​**通过将恶意 payload 与**触发快速路径的参数数量**相结合，成功**绕过了 WAF**。**
  
  ​
* ​**整个发现和绕过过程**完全基于时序分析**。**
  
  ​
* ​**这展示了时序分析可用于**逆向工程系统行为**并发现**高级别安全漏洞**（如 WAF 绕过）的潜力。**
  
  ​

~~Now, after I found that technique, it was discovered by some other people, and it has been integrated into a cool tool called NOA. So go check that out. But that detour, although it ended with a nice finding, left me wondering how many of my findings were genuine parameters exposing real attack surface. So I did a kind of case study to try and confirm this issue better. I decided to focus on HTTP headers that enable IP splicing.~~
**这段文字的大意是：**

**作者提到，他们发现的利用时间差异绕过 WAF 的技术后来也被其他人独立发现，并被集成到了一个名为 **NOA** 的工具中（推荐大家去了解）。**

​​**然而，尽管这个 WAF 绕过的发现（作者称之为“弯路”但结果不错）本身很有价值，它却让作者开始**反思**：他们通过时序分析发现的大量“参数/标头”中，有多少是**真正暴露了攻击面**的、具有实际意义的参数，又有多少仅仅是像 WAF 行为那样的**系统副作用或误报**？**

​​​​**为了更深入地探究这个问题并**确认发现的有效性**，作者决定进行一个**有针对性的案例研究 (case study)**。这次研究的重点是寻找那些能够**启用 IP 拼接 (IP splicing)** 的 HTTP 标头。**

​​**总结要点:**

* **作者发现的 WAF 绕过技术已被他人确认并集成到工具 **NOA** 中。**
* ​**这次成功让作者反思时序分析结果的**真实性**：区分真正的攻击面暴露与系统行为伪影。**
  
  ​
* ​**为解决此疑虑，作者启动了一个**案例研究**。**
  
  ​
* **该案例研究专注于寻找与 **IP 拼接**相关的 HTTP 标头。**

~~Here's an example. Detection. And you can see here when we send "True-Client-IP" with a domain name, the response comes back 5 milliseconds slower. But if we replay that request, it comes back fast again. And that is evidence of DNS caching. That 5-millisecond delay that you only get the first time is the web server that we're targeting sending a DNS lookup all the way to the authoritative server for example.com. Their operating system is saving that response in the DNS cache, so the second time around, the network round trip is skipped, and the response comes back faster.~~
​**这段文字描述了作者在**案例研究**（寻找启用 IP 拼接的 HTTP 标头）中，如何利用**时序分析**检测到一个具体的标头 (**True-Client-IP**) 及其行为。**

​* ​**具体发现 (Detection)**：

​* ​**当发送带有**域名值**的 **True-Client-IP** 标头时（例如 **True-Client-IP: example.com**），第一次请求的响应时间会**慢 5 毫秒**。**

```
​
```

* ​​**如果**重复发送完全相同的请求**，后续响应会**恢复到正常速度**（不再有 5 毫秒的额外延迟）。**
  
  ​​
* ​**原因解释**：
  
  ​* ​**这种“**首次慢，后续快**”的时间模式是**DNS 缓存 (DNS caching)** 的典型证据。**
  
  ​
  
  * ​**第一次请求时，目标 Web 服务器收到了 **True-Client-IP** 标头及其域名值，并对此域名执行了 **DNS 查询**（可能一直查到权威 DNS 服务器）。这个查询过程耗时约 5 毫秒。**
    
    ​
  * **服务器的操作系统会将这次 DNS 查询的结果**缓存**起来。**
  * ​**第二次发送相同请求时，服务器可以直接从本地 DNS 缓存获取结果，**避免了外部网络往返**，因此响应更快。**
    
    ​
* ​**意义**：这个 5 毫秒的、仅在首次出现的延迟，证明了服务器确实在**处理** **True-Client-IP** 标头中的值（通过执行 DNS 查询），这为判断该标头是否与 IP 拼接或信任机制相关提供了依据。
  
  ​

**总结要点:**

* **作者通过时序分析发现，发送带域名的 **True-Client-IP** 标头首次会引发 5ms 延迟。**
* **重复请求则无此延迟。**
* **这种现象是**服务器执行 DNS 查询并随后缓存结果**的证据。**
* **这证明了服务器在处理该标头的值，是寻找 IP 拼接相关标头案例研究中的一个具体发现。**

~~So by looking for this header and then doing a follow-up test for DNS caching, I found that of my targets, about the majority had visible DNS caching. I was also able to confirm them with an out-of-band technique, which is looking to see if changing the domain to a domain I control causes a DNS ping back to reach my server. And virtually all the targets that had visible DNS caching also caused a DNS ping back. So we can see that technique is reliable.~~
​​**这段文字总结了作者在**案例研究**（寻找启用 IP 拼接的 HTTP 标头）中的**验证过程和结果**。**

​​* ​**主要检测方法**：通过**时序分析**寻找指示 **DNS 缓存**的时间模式（首次请求慢，后续请求快），以此来初步识别可能处理 IP 地址或域名的标头。

​

* ​**初步结果**：在测试的目标中，**大多数**都表现出这种“可见的 DNS 缓存”行为。
  
  ​
* ​**验证方法**：为了确认这些基于时间差异的发现是否准确，作者使用了一种**独立的、带外 (out-of-band) 的技术**进行验证。具体做法是：
  
  ​* ​**将可疑标头的值改为一个作者**自己控制的域名**。**
  
  ​
  
  * ​**观察是否有来自目标服务器的 **DNS 查询**（"DNS ping back"）请求解析该域名，从而到达作者控制的服务器。**
    
    ​
* ​​**验证结果**：**几乎所有**通过时序分析检测到 DNS 缓存迹象的目标，**也都成功触发了 DNS ping back**。
  
  ​​
* ​​**结论**：这个验证结果表明，使用**时序分析**来检测这类触发 DNS 查询的标头的技术是**可靠的**。
  
  ​​

**总结要点:**

* **作者使用时序分析（DNS 缓存模式）初步识别了大量可能处理域名的标头。**
* ​**通过**带外 DNS 查询验证**（DNS ping back）确认了这些发现。**
  
  ​
* **验证结果显示时序分析与带外验证结果高度一致。**
* ​**因此，证明了**基于时序分析检测此类行为的方法是可靠的**。**
  
  ​

~~But what about the other 170 findings? Well, those are pretty legit from the manual sampling that I did. Here's one example. What do you think might be causing this delay when I spoof an IP address instead of a hostname? Here's a clue: when you log into the site and view your login history, they include your IP address and the location associated with that IP. So I think this delay is being caused by my IP getting passed to a third-party geolocation lookup service. And when I pass in a domain name, that's failing the IP address validation on the server and it's bypassing this network round trip, making the response come back faster. I got a bounty for that one, but the real value there was in the takeaway, which is that time analysis is really good at revealing control flow changes like exceptions.~~
**这段文字讨论了那些**未表现出 DNS 缓存模式**的另外 170 个时序分析发现。**

* ​​**发现的普遍有效性**：作者通过**手动抽样检查**，认为这 170 个发现**大多是真实的** (“pretty legit”)，而不仅仅是噪音或误报。
  
  ​​
* ​**具体案例分析**：
  
  ​* ​​**观察**：在一个案例中，当作者在某个标头中**伪造一个 IP 地址**时，响应比**伪造一个主机名**时要**慢**。
  
  ​​
  
  * ​​**线索**：该网站的登录历史记录会显示用户的 IP 地址及其**地理位置**。
    
    ​​
  * ​**推断原因**：
    
    ​* ​**当发送**有效的 IP 地址**时，服务器会将其传递给**第三方地理位置查询服务 (geolocation lookup service)**，这个**外部网络请求**导致了延迟。**
    
    ​
    
    * ​**当发送**主机名**时，服务器内部的**IP 地址格式验证失败**，导致**跳过了**对外部地理位置服务的调用，因此响应更快。**
      
      ​
* ​**价值与启示**：
  
  ​* ​**这个发现本身获得了**漏洞赏金 (bounty)**。**
  
  ​
  
  * ​​**更重要的**启示 (takeaway)** 是：时序分析非常擅长揭示服务器端**控制流的变化 (control flow changes)**，例如由于输入验证失败或其他原因引发的**异常 (exceptions)**。这些变化常常导致代码执行路径不同，从而产生可测量的时间差异。**
    
    ​​

**总结要点:**

* **作者认为大多数非 DNS 缓存模式的时序发现也是**真实有效**的。**
* ​**通过一个案例（IP vs Hostname 导致不同延迟）说明，时间差异可能由**与外部服务交互**（如地理位置查询）引起。**
  
  ​
* **当输入格式不符（如用主机名代替 IP）导致**内部验证失败**时，会**绕过**耗时的外部调用，从而响应更快。**
* ​**这个案例获得了赏金，但更重要的是证明了**时序分析能有效揭示服务器内部的控制流变化和异常处理逻辑**。**
  
  ​

~~And that realization set me up for the next phase of this research: triggering and spotting exceptions is a core part of testing for server-side injection vulnerabilities, and with timing, we can do it better. Here's my first finding. You probably recognize this classic SQL injection payload pair, but the response is completely static. It's the response time that gives the game away. I confirmed that issue, and unfortunately, when I reported it, someone else had found it first. And you can probably guess why: plenty of people look for SQL injection using sleep statements, and that doesn't require advanced timing analysis.~~
​​**这段文字标志着作者研究进入了**下一个阶段**：利用时序分析来**改进服务器端注入漏洞（如 SQL 注入）的检测**。**

​​* ​​​**核心思路**：上文提到时序分析擅长揭示**控制流变化**和**异常**。而触发并识别这些异常，正是测试**服务器端注入漏洞**的关键环节。因此，时序分析可以成为**更有效的注入漏洞检测手段**。

​​​

* ​**第一个发现（SQL 注入案例）**：
  
  ​* ​**场景**：作者使用了一对经典的 SQL 注入 payload（可能是基于条件判断的，例如 **... AND 1=1** vs **... AND 1=2**）。
  
  ​
  
  * ​​**挑战**：服务器的**响应内容完全没有变化**（"completely static"），使得基于内容的检测方法失效。
    
    ​​
  * ​**突破口**：**响应时间**暴露了漏洞（"gives the game away"）。可能是 **1=1** 条件为真时执行了更多操作或不同的代码路径，导致时间差异。
    
    ​
  * ​​**确认与结果**：作者确认了这是一个真实的 SQL 注入漏洞。然而，报告时发现**已被他人抢先发现**。
    
    ​​
  * ​​​**原因分析**：作者推测，这是因为很多安全研究人员使用基于**时间延迟（sleep/benchmark）的 SQL 注入 payload**。这种方法虽然也利用时间，但通常依赖较大的、人为制造的延迟，**不需要像作者那样进行精密的、微小时间差的分析**（"advanced timing analysis"），因此更容易被传统方法发现。
    
    ​​​

**总结要点:**

* ​**作者将研究重点转向利用时序分析检测**服务器端注入漏洞**。**
  
  ​
* ​**核心在于利用时序分析探测注入payload引发的**控制流变化或异常**。**
  
  ​
* **发现了一个**响应内容不变**但**响应时间有差异**的 SQL 注入漏洞。**
* **该漏洞已被他人通过**基于 sleep 的时间盲注**方法发现，说明传统时间盲注技术有时也能奏效，且可能更早被应用。**
* **这暗示了作者的“高级时序分析”方法可能更适用于检测**不依赖 sleep** 或延迟更细微的注入场景。**

~~So overall, we can infer timing is a bad fit for detecting injection into sleep-capable languages unless the target has a web application firewall or such that's just blocking sleep keywords. But what about less powerful injections? Well, it's seriously good for that. Here's one example. This is a blind Serde JSON injection detected thanks to a 0.2-millisecond difference in the response time. The hard part with this finding and findings like this is gaining enough understanding to actually exploit them.~~
**这段文字对比了时序分析在**不同类型注入漏洞检测**中的适用性，并给出了一个成功案例。**

* ​**不适用于 Sleep 类注入**：作者推断，对于那些**支持 **sleep** 或类似延迟函数**的注入（如常见的 SQL 时间盲注），（高级）时序分析**不是最佳选择** ("a bad fit")。因为简单的 **sleep** 就能产生足够大的时间差，更容易被传统方法检测。
  
  ​* ​**例外情况**：除非有 WAF 等防护措施**明确阻止了 **sleep** 关键词**的使用，这时时序分析可能仍有用武之地。
  
  ​
* ​**非常适用于“能力较弱”的注入**：对于那些**不支持 **sleep** 或难以直接控制执行时间**的注入场景，时序分析**非常有效** ("seriously good")。
  
  ​
* ​**成功案例（Serde JSON 注入）**：
  
  ​* ​**作者通过检测到仅 **0.2 毫秒**（即之前提到的 200 微秒）的响应时间差异，成功发现了一个**盲 Serde JSON 注入**漏洞。这展示了该技术检测微小时间信号的能力。**
  
  ​
  
  * ​​**新的挑战**：作者指出，对于这类通过细微时间差异发现的漏洞，真正的**难点**在于**深入理解其原理并找到有效的利用（exploit）方法**。
    
    ​​

**总结要点:**

* **（高级）时序分析**不适合**检测可通过 **sleep** 实现的注入（除非 **sleep** 被 WAF 拦截）。**
* **时序分析**特别擅长**检测**不支持 **sleep** 或控制流影响更微妙**的注入漏洞。**
* ​**成功利用 **0.2ms** 的时间差检测到**盲 Serde JSON 注入**，证明了技术的敏感度。**
  
  ​
* **对于这类漏洞，检测后的**理解和利用**是主要挑战。**

~~Here, we can see that there's also a client-side JSON injection in the response to us, and that seems like a bit of a coincidence. Exploring it, I saw that if I sent a long key, then the payload that I was sending to them got redacted in the reflection back to me. And crucially, that redaction made the response timing signal revert and go away. So by combining that visible information with that timing data, we can infer that something on the server is paying the same response that gets sent to us, and that's where their Serde injection is occurring. So it's potentially plug-in analytic software or something like that. Ultimately, I couldn't build an exploit for this target, so I had to give up and move on. But at least we got some understanding of what was happening.~~

**这段文字详细描述了作者试图**理解并利用**之前发现的**盲 Serde JSON 注入**的过程。**

* ​​**寻找线索**：作者注意到响应中同时存在一个**客户端可见的 JSON 反射**（client-side JSON injection in the response），这似乎与服务器端的盲注入有关（"a bit of a coincidence"）。
  
  ​​
* ​​​**关键实验**：作者发现，如果在注入的 JSON 中使用一个**很长的键 (long key)**，那么在返回给客户端的响应中，这个注入的 payload 会被**编辑或移除 (redacted)**。
  
  ​​​
* ​**重要的关联**：最关键的是，当发生这种**编辑移除**时，之前检测到的 **0.2 毫秒的时间差信号也随之消失了** ("timing signal revert and go away")。
  
  ​
* ​​​**推断过程**：将**可见的反射信息**（长键导致编辑移除）与**时间数据**（编辑移除时时间差消失）结合起来，作者推断：
  
  ​​​* ​**服务器端的某个组件正在**处理（解析）将要发送给客户端的相同响应数据**。**
  
  ​
  
  * ​**服务器端的 Serde 注入就发生在这个**解析过程中**。**
    
    ​
  * ​**因此，这个易受攻击的组件可能是某种**插件、分析软件或其他类似的东西**，它既处理请求数据，又参与构建响应。**
    
    ​
* ​​**最终结果**：尽管通过时序分析获得了对内部处理流程的理解，作者**最终未能为这个目标构建出可行的漏洞利用（exploit）**，只能放弃。
  
  ​​
* ​​**价值所在**：即使无法利用，时序分析至少帮助**理解了后台正在发生的事情**。
  
  ​​

**总结要点:**

* **作者试图利用一个响应中的**客户端可见反射**来理解服务器端的盲 Serde 注入。**
* **通过实验发现，改变输入（长键）导致反射内容被编辑，**同时**消除了之前检测到的时间差。**
* **这表明服务器端注入发生在处理将要反射给客户端的数据时（可能是分析插件等）。**
* ​**虽然最终**未能成功利用**该漏洞，但时序分析帮助**揭示了服务器内部的处理逻辑**。**
  
  ​

~~My most successful injection probe was for blind server-side parameter pollution, which worked by looking at the response time for reserved characters like hash and non-reserved characters like exclamation marks. But once again, to build an exploit, you almost need to know what to expect. Something I found helped with this is the concept of bug-uple gangers, which is non-blind variations of the same vulnerability.~~
**这段文字介绍了作者在**盲服务器端参数污染 (blind server-side parameter pollution)** 检测方面的成功，以及应对利用挑战的方法。**

* ​**成功的检测方法**：
  
  ​* **作者最成功的注入探测是针对盲服务器端参数污染。**
  
  * ​​​**检测方法是通过比较发送**保留字符**（如 **#**）和**非保留字符**（如 **!**）作为参数值时的**响应时间差异**。不同的处理方式导致了时间上的不同。**
    
    ​​​
* ​**利用的挑战**：
  
  ​* **与之前的例子类似，仅仅检测到时间差异不足以构建有效的漏洞利用（exploit）。研究人员需要对后端如何处理这些被污染的参数有**预期或理解** ("almost need to know what to expect")。**
* ​**应对挑战的思路 - “Bug Doppelgangers”**：
  
  ​* ​**作者发现一个有用的概念是寻找“**bug-uple gangers**”（可能是指 bug doppelgangers，即漏洞的“二重身”或相似体）。**
  
  ​
  
  * ​**这指的是寻找**相同类型漏洞的非盲版本 (non-blind variations)**。**
    
    ​
  * **通过研究这些**可见效果**的非盲漏洞实例，可以更好地理解漏洞机制和潜在影响。**
  * ​**然后，可以将从非盲版本获得的知识应用回通过时序分析发现的**盲版本**，从而更容易地构建利用。**
    
    ​

**总结要点:**

* ​**作者成功使用时序分析（比较保留/非保留字符的响应时间）检测到**盲服务器端参数污染**。**
  
  ​
* **利用这类盲注的主要挑战在于**理解其后端影响**以构建 exploit。**
* ​**作者提出通过研究**同类漏洞的非盲版本**（“bug doppelgangers”）来获取必要的理解和知识，以辅助盲注的利用。**
  
  ​

~~In summary, timing analysis will reveal plenty of server-side injection, but the stuff it finds can be really quite hard to exploit. The majority of my valid exploit points during this research came from the third and final phase when I realized you could use time analysis to detect a vulnerability class that had seemed almost undetectable to me for the last seven years. Back in 2017, I explored and overlooked a type of server-side request forgery. I sent a bunch of websites requests that said, "Please forward this to my server" by placing my domain in the Host header in the request sent to their site. If this request then actually arrived at my site, that meant I'd found a misconfigured reverse proxy, which I could then use to plunder their internal network. I had a lot of fun with that research and even ended up exploiting my own ISP by accident because they were man-in-the-middling me, which was rude of them.~~

**这段文字的大意是：**

​​**作者首先**总结了上一阶段（服务器端注入）的研究**：时序分析能发现很多注入点，但这些发现往往**难以利用**。**

​​​​**然后，作者引入了研究的**第三个也是最后一个阶段**，这个阶段带来了**最多有效的漏洞利用点**。这一阶段的核心是利用时序分析来检测一种作者过去七年都认为**几乎无法检测**的漏洞类型。**

​​​**作者回顾了**2017 年**的一项研究，当时他探索了一种**服务器端请求伪造 (SSRF)**：**

​* ​​​**方法**：通过修改发送给目标网站请求中的 **Host** 标头**，将其指向作者自己的域名，试图诱使目标（特别是配置错误的**反向代理**）将请求**转发**到作者的服务器。**

​​​

* ​**成功标志**：如果在作者的服务器上收到了这个转发的请求，就意味着发现了配置错误的反向代理。
  
  ​
* ​​**潜在影响**：利用这个漏洞可以访问目标的**内部网络**。
  
  ​​
* ​**趣闻**：作者甚至意外地利用此技术攻击了自己的 ISP（因为 ISP 在进行中间人攻击）。
  
  ​

​**这段文字的作用是**承上启下**：总结了注入研究的局限性，并引出了利用时序分析检测特定类型 SSRF 的新方向，并用过去的经验作为背景铺垫。暗示接下来的内容将是如何用**时序分析**来改进或重新发现这种基于 **Host** 头的 SSRF。**

​**总结要点:**

* **时序分析发现的注入漏洞通常难以利用。**
* **研究的第三阶段（成果最多）是利用时序分析检测一种长期被认为难以发现的漏洞。**
* **回顾了 2017 年利用修改 **Host** 头探测反向代理配置错误以实现 SSRF 的研究。**
* **该 SSRF 漏洞可用于访问内部网络。**
* **为后续介绍如何使用**时序分析**检测此类 SSRF 做了铺垫。**

~~But I knew that this had a blind spot. It won't detect scoped SSRF, which is where the reverse proxy will only access subdomains of the target company. There's a bunch of ways this can happen, but the result is the same: it can't—you've just got a bug that's almost as powerful as regular server-side request forgery but can't be detected using DNS pingbacks because they either won't be triggered or they won't make their way out of the target network to the attacker server.~~

​​**这段文字指出了之前（2017 年）基于 **Host** 标头和 DNS pingback 检测 SSRF 方法的一个**主要盲点**：它无法检测**范围受限的 SSRF (scoped SSRF)**。**

​​* ​​**什么是范围受限的 SSRF？**：这是一种特殊情况，其中配置错误的反向代理**只会访问目标公司自己的子域名**，而不会（或不能）访问任意外部域名（如攻击者控制的服务器）。

​​

* ​**为何难以检测？**：
  
  ​* **因为代理不会向外部发送请求，所以依赖于接收 **DNS pingback** 的传统方法会失效。**
  
  * **具体原因可能是：**
    
    * **代理配置根本**不允许**触发对外部域名的 DNS 查询。**
    * **即使触发了内部 DNS 查询，查询请求也**无法离开目标网络**到达攻击者的服务器。**
* ​**重要性**：尽管难以检测，范围受限的 SSRF 仍然是一个**非常强大**的漏洞（"almost as powerful as regular server-side request forgery"），其潜在危害接近于常规 SSRF。
  
  ​

**这段话的核心在于强调了传统 DNS pingback 方法在检测**内部限制性 SSRF** 时的局限性，为接下来介绍如何使用**时序分析**来解决这个问题埋下了伏笔。**

**总结要点:**

* ​**基于 **Host** 头的 DNS pingback 方法无法检测**范围受限的 SSRF**。**
  
  ​
* ​**范围受限的 SSRF 指代理只访问**目标自身的子域名**。**
  
  ​
* ​**传统检测方法失效是因为**无法收到来自目标网络的 DNS pingback**。**
  
  ​
* ​**范围受限的 SSRF 仍然是**一个强大的漏洞**。**
  
  ​
* **这突显了寻找新检测方法（如时序分析）的必要性。**

~~Detecting this is really quite hard. Take this response sample here. We can see they're doing Host header validation, but we don't know if they're trying to connect to the specified hostname. To detect scoped SSRF, we need to answer the question: "Are they trying to connect to the hostname in the Host header?" And timing is perfectly suited for this, thanks to the DNS caching behavior that we saw earlier. It's that easy—well, almost, because some targets don't support DNS caching or don't cache failed DNS lookups. But there's an alternative way. DNS has a maximum length, and if you go one character over that, the DNS client will either refuse to send the query and the response will come back faster, or they will just time out, and the response will take ages to come back. So by combining these two techniques, we can reliably detect almost every scoped SSRF vulnerability in existence.~~
​**这段文字阐述了如何使用**时序分析**来检测之前难以发现的**范围受限的 SSRF (scoped SSRF)**。**

​* ​**核心问题**：如何判断服务器是否真的尝试连接 **Host** 标头中指定的主机名，即使无法收到外部 DNS pingback？

​

* ​​**主要检测方法（基于时序）**：利用之前讨论过的 **DNS 缓存行为**。
  
  ​​* **发送一个指向目标子域名的 **Host** 标头。**
  
  * ​**首次请求**：如果服务器尝试连接（进行 DNS 查询），可能会有延迟。
    
    ​
  * ​**后续请求**（相同 **Host** 标头）：如果存在 DNS 缓存，响应会变快。
    
    ​
  * ​**这个“**首次慢，后续快**”的时间模式就证明了服务器确实尝试了连接。**
    
    ​
* ​**应对局限性的替代方法（基于时序）**：考虑到有些目标可能不使用 DNS 缓存或不缓存失败的查询，作者提出了另一种基于时间的技术：
  
  ​* ​**利用 **DNS 主机名的最大长度限制**。**
  
  ​
  
  * **发送一个**超过最大长度**的无效主机名作为 **Host** 标头的值。**
  * ​**两种可能结果**（都会产生时间差异）：
    
    ​* ​**DNS 客户端在发送前就**拒绝**了这个无效查询，导致跳过 DNS 查找步骤，响应**变快**。**
    
    ​
    
    * ​**客户端尝试发送或处理这个超长主机名导致**超时**，响应**变得极慢** ("take ages")。**
      
      ​
  * **无论哪种情况，与发送正常长度主机名相比，都会产生显著的时间差异，从而揭示服务器是否尝试进行 DNS 解析。**
* ​​**结论**：通过**结合这两种时序分析技术**（DNS 缓存模式检测 + DNS 最大长度探测），可以**可靠地检测几乎所有**存在的范围受限 SSRF 漏洞。
  
  ​​

**总结要点:**

* **检测范围受限 SSRF 的关键是判断服务器是否尝试连接 **Host** 头中的主机名。**
* ​**主要时序方法**：利用 **DNS 缓存**模式（首次慢，后续快）。
  
  ​
* ​​​​**替代时序方法**：利用 **DNS 最大长度限制**，发送超长主机名会导致响应**显著变快**（查询被拒）或**显著变慢**（超时）。
  
  ​​​​
* **结合这两种技术**可以高效、可靠地发现大多数范围受限 SSRF。

~~As usual, this looks kind of obvious in retrospect now that I put it on a slide, but it exposed a lot of vulnerable servers. It exposed hundreds of reverse proxies, which in turn exposed thousands of internal domains. So I decided to automate the follow-up step of finding valuable internal targets. In Param Miner, you can run this for yourself using the option "exploit scoped SSRF." What this does is it looks up every known subdomain and tries to access them twice: once directly, like a normal user would, and once through the proxy. And then it will flag if it sees any significant differences in the two responses, such as a missing header. That header might not look like much, but what it means is we found a different route to this destination, and that's where things are going to get interesting shortly.~~
**这段文字的大意是：**

​​**作者回顾并肯定了使用时序分析检测**范围受限 SSRF** 的方法非常有效，尽管事后看来可能显得简单，但它成功**暴露了大量（数百个）配置错误的反向代理**，进而揭示了**数千个内部域名**。**

​​​​**由于发现了如此多的潜在入口点，作者决定**自动化下一步**：在这些暴露的内部网络中**寻找有价值的目标**。**

​​* ​**自动化工具与功能**：这个自动化功能已集成到 **Param Miner** 工具中，通过 **exploit scoped SSRF** 选项启用。

​

* ​**工作原理**：
  
  ​* **该功能会遍历已知的目标子域名列表。**
  
  * ​​​**对每个子域名，尝试进行**两次访问**：一次是**直接访问**（模拟普通用户），另一次是**通过已发现的配置错误的反向代理**（利用 SSRF）。**
    
    ​​​
  * ​**比较这两次访问的**响应差异**。**
    
    ​
* ​​​**关键指标**：寻找响应中的**显著差异**，例如通过代理访问时**缺少某个 HTTP 标头**。
  
  ​​​
* ​​**差异的意义**：即使只是缺少一个看似不重要的标头，也意味着通过代理的请求**走了不同的网络路径或经过了不同的处理**。
  
  ​​
* ​**预示**：这种“不同的路径”正是接下来进行更深入利用或发现有趣行为的关键所在。
  
  ​

**总结要点:**

* ​**时序分析检测范围受限 SSRF 的方法被证明**非常成功**，发现了大量入口点。**
  
  ​
* **作者开发了**自动化工具 (Param Miner)** 来探索这些入口点，寻找内部有价值的目标。**
* **自动化工具通过**比较直接访问和通过代理访问同一目标的响应差异**来工作。**
* ​**响应差异（如缺少标头）表明通过代理访问**走了不同的路径**。**
  
  ​
* **这些“不同路径”是进一步挖掘漏洞的关键。**

~~On the service, this Host header guessing strategy is really quite similar to virtual host brute forcing, but the outcomes and opportunities it gives us are very different. The findings fell into four main categories, and the first three are hilariously easy to exploit. The simplest exploit is where you can see the target from outside but can't directly access it. For example, on one target, you could see the DNS record pointing at their SonarQube installation, but the firewall would just reset your connection. But using the reverse proxy, I was able to defeat the firewall by going around it. That's the key use of reverse proxies: you see the defense, and then you go around it.~~
​**这段文字描述了利用**范围受限 SSRF (scoped SSRF)** 进行自动化探测后的**发现和利用类型**。**

​* ​**与虚拟主机爆破的比较**：作者指出，这种基于 **Host** 标头的探测策略与传统的虚拟主机爆破在技术上相似，但产生的**结果和利用机会**截然不同。

​

* ​​**发现分类**：探测到的结果主要分为**四类**，其中**前三类非常容易利用** ("hilariously easy to exploit")。
  
  ​​
* ​**第一类利用场景：绕过直接访问限制**：
  
  ​* ​​​**场景描述**：某个内部目标（如 SonarQube 安装）从外部是**可见的**（例如，存在 DNS 记录），但**无法直接访问**（例如，被防火墙拦截导致连接重置）。
  
  ​​​
  
  * ​​**利用方法**：利用之前发现的配置错误的反向代理（通过 scoped SSRF），可以**绕过防火墙**，成功访问到这个本应被阻止的目标。
    
    ​​
  * ​**核心原理**：反向代理提供了一条不同的访问路径，可以绕开直接访问路径上的防御措施。这就是利用反向代理进行攻击的关键：“看到防御，然后绕过去”。
    
    ​

**总结要点:**

* **基于 **Host** 头的 SSRF 探测与虚拟主机爆破技术相似，但利用机会不同。**
* **发现分为四类，前三类利用简单。**
* ​​**第一类利用**：针对那些**可见但直接访问被阻止**（如防火墙）的目标。
  
  ​​
* **利用反向代理提供的**替代路径**来**绕过**这些直接防御措施。**
* ​**核心思想是利用代理“**绕过防御**”。**
  
  ​

~~There's a common variation where the internal system doesn't have a public DNS record, but it does have a private one, which the reverse proxy can access. There's a huge number of pre-prod environments exposed to anyone using this technique. But the most interesting targets I found during this research were pre-launch systems that were still under construction. In particular, I discovered an administration console with apparently public access on a seriously cool-looking US government system, which I'm gutted I can't provide any additional details about. I reported that issue, and when the system went live a few months later, the admin console was nowhere in sight, so it looks fixed.~~

### 一、文字内容讲解

1. **反向代理与DNS配置问题**
   • 原文描述了一种常见技术场景：**内部系统**未设置公共DNS记录（无法通过互联网直接解析），但配置了**私有DNS记录**（仅内部网络或特定组件可识别）。
   • **反向代理**（如Nginx、HAProxy）作为中间层，可通过私有DNS访问内部系统，并将其服务暴露给外部用户。这种设计常用于隔离后端服务，但若配置不当会导致风险。
2. **预生产环境暴露风险**
   • 使用上述技术时，大量**预生产环境**（pre-prod，如测试、开发环境）可能被意外暴露给任意用户。这些环境通常未经过严格安全加固，易成为攻击入口。
3. **高危案例：未完成系统的漏洞**
   • 作者在研究中发现更具威胁的目标：**预发布系统**（pre-launch systems），即尚未正式上线、仍在开发中的系统。
   • 具体案例：某**美国政府系统**的管理控制台在开发阶段意外开放了公共访问权限。尽管作者无法透露细节，但该漏洞可能导致未授权用户访问敏感功能或数据。
4. **漏洞修复与验证**
   • 作者向相关方报告此问题后，系统在正式上线时移除了管理控制台的公开访问入口，表明漏洞已修复。这一过程验证了开发阶段安全配置的重要性。

---

### 二、核心内容归纳总结

**1. 主要风险**
• **反向代理与私有DNS的配置漏洞**：未严格隔离预生产环境，导致本应内部访问的系统被外部暴露。
• **开发阶段的安全疏忽**：未完成系统（如管理控制台）因临时配置遗留问题，形成高危攻击面。

**2. 实际影响**
• 预发布环境可能成为攻击者渗透的跳板，甚至影响政府等高安全需求系统。
• 案例证明，开发阶段的漏洞可能延续至生产环境，需通过上线前审查彻底规避。

**3. 安全启示**
• **访问控制强化**：限制反向代理仅暴露必要服务，避免私有DNS滥用。
• **全周期安全管理**：从开发到上线全程监控配置，及时清理测试环境残留权限。

~~I found a similar issue in Red Bull, which is mainly notable because they paid me in cans rather than cash. Other valuable targets are publicly accessible but sit behind front-end servers that enforce inconvenient security rules that block attacks or restrict access to valuable endpoints. On one target, there was an internal admin console that just gave a 403, but by going around that front-end, I could access the system and log in as a normal user.~~

### 一、文字内容讲解

1. **Red Bull漏洞案例的非典型性**
   • 作者在Red Bull系统中发现了一个**安全漏洞**，但因厂商非传统响应方式引发关注：**漏洞奖励是实物（罐装饮料）而非现金**。案例特殊性在于其反映厂商对安全的优先级或预算分配态度。
2. **前端服务器的安全限制与绕过**
   • 许多高价值目标系统虽然对外公开访问，但通过**前端服务器**（如负载均衡器、WAF）设置了安全规则：
   ◦ **拦截攻击流量**（如注入、暴力破解）
   ◦ **限制访问敏感端点**（如API接口、管理后台）
   • **攻击规避手段**：
   ◦ 通过技术方法（如域名/IP直连后端、端口探测）绕开前端安全检查，**直接访问后端系统**。例如：某个目标的内部管理界面返回403（禁止访问），但绕过前端后，攻击者能直接访问并**以普通用户身份登录**，显示前后端权限验证的不一致性。
3. **安全防御的盲区**
   • 部分场景中，**前端防护与后端系统未完全协同**，例如：
   ◦ 前端仅部分过滤请求，后端缺乏二次验证机制
   ◦ 内网API或控制台未遵循最小权限原则，暴露默认低权限入口

---

### 二、核心内容归纳总结

**1. 主要风险与漏洞模式**
• **前端防护的单点依赖**：仅依靠前端安全规则（如WAF）拦截攻击，后端缺乏纵深防御，易被绕过。
• **权限验证漏洞**：用户身份验证未贯穿前后端（如绕过后可降权登录），可能暴露未授权功能或数据。

**2. 典型案例启示**
• **厂商安全意识差异**：漏洞披露后的响应方式（如实物替代现金奖励）暗示企业对安全优先级的不同认知。
• **攻击面扩展**：绕过前端的访问路径（如直接连接内网服务）可能成为突破点，攻击者利用规则差异实现权限越级（即使是普通用户权限）。

**3. 防护建议**
• **纵深防御**：前后端统一身份认证与权限控制，避免仅依赖前端拦截。
• **端到端监控**：部署日志审计与异常访问检测，尤其关注绕过标准入口的流量（如非常规端口或内部域名调用）。
• **漏洞管理规范化**：明确漏洞奖励机制，鼓励白帽研究者参与协作。

~~The final and most subtle category is front-end impersonation attacks. Front-end servers often add internal HTTP headers onto requests before forwarding them to the back-end, and the back-ends trust these implicitly, which enables a type of attack that's kind of known in pieces but not appreciated as a full standalone bug class. Everyone knows that you can spoof an IP address using headers, but few people are paying attention to what else gets transmitted in these headers. And yes, that's two real examples from New Relic.~~
【意译改写】
在网络安全领域，最隐蔽且常被低估的威胁类别是前端服务器身份伪造攻击。这类攻击利用了一个系统设计漏洞：前端服务器在将请求转发给后端服务时，会自动附加内部HTTP请求头信息，而后端系统默认完全信任这些附加信息。虽然安全人员普遍知道通过伪造X-Forwarded-For等标头可以伪造IP地址，但鲜少有人关注到其他敏感标头信息可能被滥用的风险。值得警惕的是，知名监控服务New Relic的实战案例已证实这类攻击的真实存在性。

【核心提炼】

1. 攻击特征：利用前后端系统间的信任链漏洞，通过伪造HTTP标头实现身份冒充
2. 隐蔽性成因：安全人员对IP伪造之外的标头攻击缺乏系统认知
3. 风险级别：已形成独立攻击类型但尚未被充分重视
4. 实证依据：基于New Relic平台发现的两个真实攻击案例

~~In theory, this header behavior is safe, right? Because if an attacker spoofs a header, the front-end will just overwrite it. But with a reverse proxy, we can just go around the front-end, bypass the header overwrite, impersonate the front-end to the back-end, and exploit this trust relationship. In addition to being exploitable via reverse proxies, you can also exploit this via unintended direct access to the back-end or with request smuggling, which is how I exploited New Relic in the example on the previous slide. Or with header masking or mutation techniques, front-end impersonation attacks are really powerful, and the only hard part is guessing the names of the internal headers, which is something that timing can help with.~~
【意译改写】
表面上看，这种HTTP标头机制似乎是安全的——当攻击者伪造标头时，前端服务器理应覆盖可疑值。但通过反向代理架构的漏洞，攻击者可以实施多重突破：既可通过旁路前端直连后端，也可借助请求走私技术穿透系统边界（这正是我在New Relic案例中的攻击路径），甚至利用标头隐藏/变形技术绕过检测。此类攻击的核心难点仅在于破译内部标头命名规则，而通过时序分析等技巧，攻击者仍能有效定位关键标头参数。

【要点凝练】

1. **安全假象破除**：传统认知中的标头覆盖机制存在系统性盲区
2. **攻击向量图谱**：
   • 反向代理架构的权限穿透
   • 非授权直连后端服务
   • 请求走私流量挟持
   • 标头参数动态伪装技术
3. **技术突破难点**：内部标头命名规则的逆向推导（辅以时序分析等辅助手段）
4. **防御启示**：需建立标头白名单机制，强化服务间认证，严格隔离内外网通信路径

~~So that's all the techniques I've got for you. We've seen timing analysis is useful for recon, reverse engineering, and finding exploits. If you'd like to try those techniques out for yourself, I've made a small CTF at "Listen to the Whispers." For me, this research is only a success if people actually start using timing attacks day-to-day. I had planned to spend a month after this presentation improving the tooling, but obviously, I've got other plans now. But at some point, I am going to do this. So if you have any issues with these tools, please let me know, and I'll take a look. I'd love to hear feature requests for them too.~~

【意译改写】
今天分享的技术方法论至此告一段落。我们深入剖析了时序分析在渗透测试中的三重价值——既可作为侦查阶段的数字听诊器，又能作为逆向工程中的暗码破译工具，更可成为漏洞利用的精准导引。为帮助各位实践演练，我特别设计了名为"窃听密语"的CTF挑战平台。对我而言，这项研究的终极意义在于推动时序攻击技术从实验室走向实战场景。尽管原计划在演讲后用一个月完善配套工具链，但受突发安排影响需暂缓推进。未来必将重启该计划，因此诚挚邀请各位在使用过程中提交问题报告或功能需求，这将为工具进化提供重要方向。

【要点凝练】

1. **技术价值三角**：
   • 侦查测绘：通过时序差异探测系统特征
   • 逆向分析：解析隐蔽的系统响应机制
   • 漏洞利用：构建精准的攻击载荷
2. **实践赋能**：
   • 部署"窃听密语"CTF作为技术试验场
   • 倡导时序分析从理论武器转化为日常渗透工具
3. **开发路线图**：
   • 短期受阻：原定的工具链优化计划延期
   • 长期承诺：持续迭代攻击框架并开放用户反馈通道
4. **社区共建**：
   • 建立问题反馈与功能需求的双向沟通机制
   • 通过用户洞察驱动工具智能化升级

~~As far as further research goes, I think the most valuable thing you can do at this point with the least amount of effort is finding valuable questions that time analysis can be used to answer and also looking at specific frameworks and services to find widespread signal amplification techniques, which may make things like that string comparison attack actually possible on those targets.~~
意译版本：
关于后续研究，我认为现阶段最有效且费力最少的方式是：首先识别那些可以通过时态分析方法解答的关键性研究问题，同时深入考察具体技术框架与服务系统，从中挖掘具有广泛适用性的信号放大技术，这或许能让类似字符串比较攻击这类手段在特定目标系统中真正具备可行性。

总结提炼：
本段内容提出了后续研究的三个核心方向：

1. 研究问题定位：筛选适合用时态分析方法解答的高价值问题
2. 技术框架分析：针对具体技术架构和服务系统进行深度研究
3. 攻击方法探索：开发可广泛适用的信号放大技术，以实现对目标系统的有效渗透（如字符串比较攻击等新型攻击方式）

该研究路径强调以最小研究成本获取最大价值，重点关注方法论创新与技术漏洞的关联性，为后续安全攻防研究提供了明确的技术攻关方向。

~~For defense, don't use wildcard routing in reverse proxies. It's not a good idea. In general, basically, when you're coding an application, assume attackers have full visibility on your server-side execution flow. They can't read your variables, but they can see which branches your code is taking and maybe things like how many iterations each loop is going through. If someone reports a proof of concept using only timing-based evidence, then, well, yeah, ask for evidence, but patch it anyway because your server, your security, should not rely on noise.~~
意译版本：
在防御层面，切勿在反向代理中使用通配符路由。这种做法存在隐患。一般来说，开发应用时要假设攻击者能够完全观察到服务器端的执行流程：他们无法直接读取变量内容，但能通过程序分支选择、循环次数等运行时特征推断逻辑走向。若收到利用时间差证据提出的概念验证（PoC）报告，尽管可以要求提供具体证据，但必须立即修复漏洞——因为服务器的安全性不应依赖于不可控的随机干扰（如噪声）来掩盖潜在风险。

总结提炼：
本段内容强调了安全防御的三大关键原则：

1. **架构设计规范**：禁止在反向代理中使用通配符路由，消除基础架构层面的潜在漏洞
2. **威胁建模假设**：开发时必须假设攻击者具备以下能力：
   - 能观察代码分支选择（如if/else路径）
   - 能监测循环结构的迭代次数等时间特征
3. **响应处置策略**：
   - 对基于时序分析的漏洞报告采取"零信任验证+立即修复"原则
   - 安全防护必须建立在确定性防御机制上，不能依赖随机噪声掩盖逻辑漏洞

（注：文中"rely on noise"指不能寄希望于系统噪声干扰攻击者的时间测量，真正的安全防护需消除漏洞根源而非依赖偶然性干扰）

~~If you're configuring a server, you can break the single packet attack using a micro-throttle as a defense-in-depth measure. There's lots of further reading available if you just go to the white paper on ports.net research, which contains all the other links on this page. If you enjoyed this talk, you may also like the following two talks from my colleagues. Gareth is talking this afternoon, and his talk will leave you terrified of email addresses. Martin's talk tomorrow is going to cause some panic among certain CDN vendors.~~
意译版本：
在配置服务器时，可通过部署微节流（micro-throttle）机制防御单包攻击，作为纵深防御体系的重要补充。若想深入学习相关技术，可访问ports.net research发布的白皮书，该文档已整合本页提及的所有扩展阅读资源。若您对本次分享感兴趣，还可关注以下两场同事的演讲：Gareth今日下午的演讲将揭示电子邮件地址隐藏的巨大安全风险，而Martin明早的演讲则可能引发部分CDN服务商的强烈关注（因其内容可能暴露某些关键漏洞）。

总结提炼：
本段内容包含三方面信息：

1. **安全配置建议**：
   - 使用"微节流"技术防御单包攻击（Single Packet Attack）
   - 强调"纵深防御"（Defense-in-Depth）原则的实施
2. **技术资源指引**：
   - 推荐访问ports.net research白皮书获取完整技术文档与扩展链接
3. **关联演讲预告**：
   - Gareth演讲核心：电子邮件地址的潜在安全威胁
   - Martin演讲影响：可能引发CDN服务商对特定安全漏洞的紧急响应

（注：微节流技术通过精细化控制数据包处理速率，干扰攻击者的时间测量分析；白皮书中的链接资源可帮助构建完整的防御知识体系）

~~The three key things to remember are: web timing attacks can answer some seriously difficult questions. The single packet attack makes them local, universal, and feasible. And the murmurs are always there; they're just waiting for you to listen.~~
意译版本：
需要牢牢记住的三个核心要点是：

1. **时序攻击的破局能力**——Web时序攻击能破解一些看似无法解答的高难度安全问题；
2. **单包攻击的革命性**——这种攻击方式使时序攻击具备本地化、普适性和可操作性，彻底改变了攻防格局；
3. **隐患的沉默存在**——系统中潜在的漏洞线索始终存在，它们就像等待被破译的暗语，只等安全团队主动去发现与应对。

总结提炼：
这段内容以诗意化的表达，揭示了网络安全领域三个关键认知：

1. **时序攻击的颠覆性价值**：
   
   - 传统认为"无法攻破"的复杂安全问题，可能通过时序分析被破解
   - 例：通过测量服务器响应时间差异，推断加密密钥或敏感数据
2. **单包攻击的三大特性**：
   
   - **本地化**：无需持续交互，单个数据包即可触发漏洞
   - **普适性**：适用于绝大多数网络服务架构
   - **可行性**：降低了攻击的技术门槛，使时序攻击从理论变为现实威胁
3. **安全防御的哲学警示**：
   
   - "murmurs"隐喻系统中持续存在的隐蔽漏洞（如时序差异、流量特征等）
   - 强调主动防御思维：安全团队需建立持续监测机制，而非被动等待漏洞爆发
   - 类比"冰山理论"：水面下的安全隐患远比可见问题更为庞大复杂

（注：第三点的"murmurs"可理解为系统运行时产生的细微异常信号，这些信号若未被及时捕捉分析，可能演变为重大安全事件）

~~I'm going to take a couple of minutes of questions now, and if you have any more after that, feel free to chuck me an email. Don't forget to follow me on X. Thank you for listening, folks. We do have a couple of minutes for questions. If anyone has any, um, make a single-file line on all three microphones, and we should be able to hear you.~~

意译版本：
"现在我将留出几分钟时间回答大家的提问。如果后续仍有问题，随时可以通过邮件联系我。别忘了在X平台（Twitter）关注我。感谢各位的聆听！我们有几分钟的问答环节，如果有问题，请各位依次排成一列走向三个麦克风区域，我们会确保您的声音被清晰收录。"

总结提炼：
本段内容包含以下核心信息：

1. **问答环节安排**：
   
   - 现场留出5分钟进行即席提问
   - 后续问题可通过邮件沟通
2. **社交传播提示**：
   
   - 明确要求听众在X（Twitter）平台关注演讲者账号
3. **流程管理规范**：
   
   - 提问者需按"单列排队"规则使用三个麦克风点
   - 目的是确保现场秩序和声音收录质量
4. **礼貌性收尾**：
   
   - 以感谢语强化听众互动体验
   - 通过细节指引（如排队方式）体现专业会务安排

（注："single-file line"特指听众需排成直线依次使用麦克风，避免多人同时靠近导致声音干扰，是演讲场合常见的技术性指引）
